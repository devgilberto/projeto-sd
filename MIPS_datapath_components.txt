// Datapath_components.sv
// Define os componentes do datapath do processador MIPS de ciclo único.
// Inclui ALU, memórias de dados e instruções, banco de registradores e contador de programa.

module ALU (
    input logic [31:0] SrcA, SrcB,           // Entradas da ALU
    input logic [2:0] ALUControl,            // Sinal que define a operação
    output logic [31:0] ALUResult,           // Resultado da operação
    output logic Zero                        // Indica se o resultado é zero
);
    // Executa operação selecionada por ALUControl
    always_comb begin
        case (ALUControl)
            3'b000: ALUResult = SrcA & SrcB; // AND
            3'b001: ALUResult = SrcA | SrcB; // OR
            3'b010: ALUResult = SrcA + SrcB; // ADD
            3'b110: ALUResult = SrcA - SrcB; // SUB
            3'b111: ALUResult = (SrcA < SrcB) ? 32'd1 : 32'd0; // SLT
            default: ALUResult = 32'd0;      // Padrão
        endcase
        Zero = (ALUResult == 32'd0);         // Define Zero para desvios
    end
endmodule

module DataMemory (
    input logic clk,                         // Clock do sistema
    input logic MemRead,                     // Habilita leitura
    input logic MemWrite,                    // Habilita escrita
    input logic [31:0] Address,              // Endereço de acesso
    input logic [31:0] WriteData,            // Dados a serem escritos
    output logic [31:0] ReadData             // Dados lidos
);
    logic [7:0] memory [255:0];              // Memória de 256 bytes

    // Leitura combinacional
    always_comb begin
        if (MemRead)
            ReadData = {memory[Address], memory[Address+1], memory[Address+2], memory[Address+3]}; // Monta palavra de 32 bits
        else
            ReadData = 32'd0;
    end

    // Escrita síncrona
    always_ff @(posedge clk) begin
        if (MemWrite) begin
            memory[Address]   <= WriteData[31:24];
            memory[Address+1] <= WriteData[23:16];
            memory[Address+2] <= WriteData[15:8];
            memory[Address+3] <= WriteData[7:0];
        end
    end
endmodule

module InstructionMemory (
    input logic [31:0] Address,              // Endereço da instrução (PC)
    output logic [31:0] Instruction          // Instrução lida
);
    logic [31:0] memory [255:0];             // Memória de 256 palavras

    // Exemplo de inicialização (substitua com instruções reais)
    initial begin
        memory[0] = 32'h20020005;           // addi $2, $0, 5
        memory[1] = 32'h2003000c;           // addi $3, $0, 12
        // Adicione mais instruções
    end

    assign Instruction = memory[Address >> 2]; // Acessa palavra de 32 bits
endmodule

module ProgramCounter (
    input logic clk,                         // Clock do sistema
    input logic reset,                       // Sinal de reset
    input logic [31:0] PCNext,               // Próximo PC
    output logic [31:0] PC                   // PC atual
);
    // Atualiza PC na borda de subida do clock
    always_ff @(posedge clk or posedge reset) begin
        if (reset)
            PC <= 32'd0;                     // Reseta para 0
        else
            PC <= PCNext;                    // Atualiza para próximo endereço
    end
endmodule

module RegisterFile (
    input logic clk,                         // Clock do sistema
    input logic RegWrite,                    // Habilita escrita
    input logic [4:0] ReadReg1, ReadReg2,    // Registradores a serem lidos
    input logic [4:0] WriteReg,              // Registrador a ser escrito
    input logic [31:0] WriteData,            // Dados a serem escritos
    output logic [31:0] ReadData1, ReadData2 // Dados lidos
);
    logic [31:0] registers [31:0];           // 32 registradores de 32 bits

    initial begin
        registers[0] = 32'd0;                // $zero sempre 0
    end

    // Leitura combinacional
    assign ReadData1 = (ReadReg1 == 0) ? 32'd0 : registers[ReadReg1];
    assign ReadData2 = (ReadReg2 == 0) ? 32'd0 : registers[ReadReg2];

    // Escrita síncrona
    always_ff @(posedge clk) begin
        if (RegWrite && WriteReg != 0)
            registers[WriteReg] <= WriteData; // Evita escrita em $zero
    end
endmodule
