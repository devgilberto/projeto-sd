// Design
// MIPS datapath components

//-------------------------------
// Módulo: register (Registrador com Enable)
//-------------------------------
module register #(
  parameter width = 32
)(
  input  logic clk,
  input  logic rst,
  input  logic ld,
  input  logic [width-1:0] D,
  output logic [width-1:0] Q
);
  always_ff @(posedge clk) begin
    if (rst == 1)
      Q <= 0;
    else if (ld == 1'b1)
      Q <= D;
  end
endmodule

//-------------------------------
// Módulo: registerFile (Banco de Registradores)
//-------------------------------
module registerFile #(
  parameter adsWidth = 5,
  parameter regWidth = 32
)(
  input  logic clk,
  input  logic rst,
  input  logic ld,
  input  logic [adsWidth-1:0] wrAds,
  input  logic [regWidth-1:0] D,
  input  logic [adsWidth-1:0] rdAds1,
  input  logic [adsWidth-1:0] rdAds2,
  output logic [regWidth-1:0] Q1,
  output logic [regWidth-1:0] Q2
);
  logic [2**adsWidth-1:0] wrEnable;
  logic [2**adsWidth-1:0][regWidth-1:0] Q;
  
  genvar i;
  generate
    for (i = 0; i < (2**adsWidth); i++) begin : word
      register #(regWidth) line (clk, rst, wrEnable[i], D, Q[i]);
    end
  endgenerate
  
  assign Q1 = Q[rdAds1];
  assign Q2 = Q[rdAds2];
  
  always_comb begin
    if (ld == 1)
      wrEnable[wrAds] = 1;
    else
      wrEnable = 0;
  end
endmodule

//-------------------------------
// Módulo: ALU (Unidade Lógica e Aritmética)
//-------------------------------
module ALU #(
  parameter size = 32
)(
  input  logic [size-1:0] A,
  input  logic [size-1:0] B,
  input  logic [2:0] ALUctrl,
  output logic [size-1:0] RES,
  output logic zero
);
  always_comb begin
    case (ALUctrl)
      3'b000: RES = A & B;
      3'b001: RES = A | B;
      3'b010: RES = A + B;
      3'b110: RES = A - B;
      3'b111: RES = (A << B) ? 1 : 0;
      default: RES = 0;
    endcase
    zero = (RES == 0);
  end
endmodule

//-------------------------------
// Módulo: ALUctrl (Controlador da ALU)
//-------------------------------
module ALUctrl(
  input  logic [5:0] funct,
  input  logic [1:0] ALUop,
  output logic [2:0] ALUctrl
);
  always_comb begin
    if (ALUop == 2'b10) begin
      case (funct)
        32: ALUctrl = 3'b010;
        34: ALUctrl = 3'b110;
        36: ALUctrl = 3'b000;
        37: ALUctrl = 3'b001;
        42: ALUctrl = 3'b111;
        default: ALUctrl = 3'b000;
      endcase
    end else if (ALUop == 2'b00)
      ALUctrl = 3'b010;
    else if (ALUop == 2'b01)
      ALUctrl = 3'b110;
    else
      ALUctrl = 3'b000;
  end
endmodule

//-------------------------------
// Módulo: adder (Somador)
//-------------------------------
module adder #(
  parameter size = 32
)(
  input  logic [size-1:0] A,
  input  logic [size-1:0] B,
  output logic [size-1:0] RES
);
  always_comb begin
    RES = A + B;
  end
endmodule

//-------------------------------
// Módulo: SL2 (Shift Left 2)
//-------------------------------
module SL2 #(
  parameter IN_WIDTH = 32,
  parameter OUT_WIDTH = IN_WIDTH + 2
)(
  input  logic [IN_WIDTH-1:0] IN,
  output logic [OUT_WIDTH-1:0] OUT
);
  always_comb begin
    OUT = {IN, 2'b00};
  end
endmodule

//-------------------------------
// Módulo: SEX (Sign Extender)
//-------------------------------
module SEX #(
  parameter insize = 16,
  parameter outsize = 32
)(
  input  logic [insize-1:0] IN,
  output logic [outsize-1:0] OUT
);
  always_comb begin
    OUT = {{(outsize-insize){IN[insize-1]}}, IN};
  end
endmodule

//-------------------------------
// Módulo: dataMem (Memória de Dados)
//-------------------------------
// Versão simplificada sem output de debug
module dataMem #(
  parameter adsWidth = 6,    // 6 bits -> 64 posições
  parameter byteWidth = 8
)(
  input  logic clk,
  input  logic [adsWidth-1:0] wrRdAds,
  input  logic wrEn,
  input  logic [4*byteWidth-1:0] D,
  input  logic rdEn,
  output logic [4*byteWidth-1:0] Q
);
  
  // Definindo a memória como um array de bytes
  logic [2**adsWidth-1:0][byteWidth-1:0] MEM;
  
  // Lógica de leitura: se rdEn estiver ativo, concatena 4 bytes consecutivos
  always_comb begin
    if (rdEn == 1)
      Q = {MEM[wrRdAds], MEM[wrRdAds+1], MEM[wrRdAds+2], MEM[wrRdAds+3]};
  end
  
  // Lógica de escrita (sem mensagens de debug)
  always_ff @(posedge clk) begin
    if (wrEn == 1)
      {MEM[wrRdAds], MEM[wrRdAds+1], MEM[wrRdAds+2], MEM[wrRdAds+3]} <= D;
  end
  
endmodule

//-------------------------------
// Módulo: instMem (Memória de Instruções)
//-------------------------------
module instMem #(
  parameter adsWidth = 6,    // 6 bits -> 64 posições
  parameter byteWidth = 8
)(
  input  logic [adsWidth-1:0] rdAds,
  output logic [4*byteWidth-1:0] Q
);
  
  logic [byteWidth-1:0] MEM [2**adsWidth-1:0];
  
  initial begin
    $readmemh("MIPS_intructions.txt", MEM);
  end  
  
  always_comb begin
      Q = {MEM[rdAds], MEM[rdAds+1], MEM[rdAds+2], MEM[rdAds+3]};
  end
  
endmodule
